#pragma once
#include <algorithm>
#include <iostream>
#include <memory>
#include <queue>
#include <sstream>
#include <string>
#include <vector>
using namespace std;
struct Node {
  char data;
  int freq;
  Node *left;
  Node *right;
  int counter;
  Node(char d, int f, int c) {
    left = nullptr;
    right = nullptr;
    data = d;
    freq = f;
    counter = c;
  }
};

struct compare {
  bool operator()(const Node *left, const Node *right) {
    if (left->freq == right->freq) {
      if (left->data == right->data) {
        return left->counter < right->counter;
      }
      return (int)left->data > (int)right->data;
    }
    return left->freq > right->freq;
  }
};

class huffman {
private:
  Node *head;

public:
  huffman() { head = nullptr; }
  Node *getHead() { return head; }
  void printCodes(Node *root, string str) {
    if (root == nullptr) {
      return;
    }
    printCodes(root->left, str + "0");
    if (root->data != '\0') {
      cout << "Symbol: " << root->data << ", Frequency: " << root->freq
           << ", Code: " << str << endl;
    }
    printCodes(root->right, str + "1");
  }

  Node *createTree(vector<pair<char, int>> &a) {
    Node *left, *right, *top;
    int count = 0;
    priority_queue<Node *, vector<Node *>, compare> pq;
    for (auto pair : a) {
      pq.push(new Node(pair.first, pair.second, count));
      count++;
    }

    while (pq.size() > 1) {
      left = pq.top();
      pq.pop();
      right = pq.top();
      pq.pop();

      top = new Node('\0', left->freq + right->freq, count++);
      top->left = left;
      top->right = right;

      pq.push(top);
    }
    head = pq.top();
    return head;
  }
  string decode_file(string s) {
    Node *curr = head;
    string final;
    for (char c : s) {
      if (c == '0') {
        curr = curr->left;
      } else {
        curr = curr->right;
      }
      if (!curr->left && !curr->right) {
        final += curr->data;
        curr = head;
      }
    }
    return final + "\0";
  }
  char decodeSymbol(string s) {
    Node *curr = head;
    string final;
    for (char c : s) {
      if (c == '0') {
        curr = curr->left;
      } else {
        curr = curr->right;
      }
    }
    return curr->data;
  }
  /*void decompressSymbol(string code, vector<int> &positions, char *memory) {
    char symbol = decode_file(code);
    for (int pos : positions) {
      memory[pos] = symbol;
    }
  }*/
};
struct argsdata {
  Node *root;
  string line;
  char *result;

  pthread_mutex_t *bsem;
  pthread_mutex_t *parent;
  pthread_cond_t *waitTurn;
  int *turn;
	int threadturn;
};
void *decodeMSG(void *ptr) {
  argsdata *args = (argsdata *)ptr;
  pthread_mutex_unlock(args->parent);
  Node *curr = args->root;
  stringstream ss(args->line);
  string s;
  ss >> s;
  for (auto h : s) {
    if (h == '0') {
      curr = curr->left;
    } else {
      curr = curr->right;
    }
  }

  char c = curr->data;
  int nums;
  

  while (ss >> nums) {
    args->result[nums] = c;
  }
  
  pthread_mutex_lock(args->bsem);
	while (*args->turn != args->threadturn) {
    pthread_cond_wait(args->waitTurn, args->bsem);
  }
  std::cout << "Symbol: " << curr->data << ", Frequency: " << curr->freq << ", Code: " << s << std::endl;
  *args->turn = (*args->turn) + 1;
  pthread_cond_broadcast(args->waitTurn);
  pthread_mutex_unlock(args->bsem);
  return NULL;
}