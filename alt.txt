#include <iostream>
#include "huffmanTree.h"
#include "pthread.h"
#include <string>
#include <sstream>
#include <fstream>
#include <vector>
#include <map>
#include <queue>
#include <string.h>
#include <stdlib.h>
#include <fcntl.h>

// Programming Assignment 3
// This assignment will introduce you to interprocess synchronization mechanisms in UNIX using named
// POSIX semaphores, pthread mutex semaphores, and pthread condition variables.

// NOTE TO TAs:
// ONLINE RESOURCES USED FOR IMPLEMENTATIONS LISTED WHERE USED/APPROPIATE

// Printing will be in order of input from "compressed"

//-----------------------------------------------------------------------------------------------------------------------------

// struct to encapsulate info to pass to thread function
struct threadArguments
{
    // TODO: Add Needed Mutex Arguments (if needed)
    // we need the root of the tree, binary message we need to decode, the decoded character, the indexes of where the
    // decoded character will be in our constructed string, and somewhere to store our output
    treeNode *huffmanTreeRoot;
    std::string binaryMsg;
    int frequency;
    char binaryDecodedCharacter;
    std::vector<int> positionsVector;
    char *output;

    // Mutexes
    // mutexArguments* mutexInfo;
    pthread_mutex_t *bsem;
    pthread_cond_t *waitTurn;
    int threadTurn;
    int *turn;

    // constructor
    threadArguments(){};
};
// thread void function
void *printTreeAndDecodeBinaryString(void *args)
{
    threadArguments *argsPtr = (threadArguments *)args;

    // TODO: Save struct info into local variable so you're not using different struct memory addresses
    // Copy Struct Info to Local Variable
    treeNode *_huffmanTreeRoot = argsPtr->huffmanTreeRoot;
    std::string _binaryMsg = argsPtr->binaryMsg;
    std::vector<int> _positionsVector;
    char *_output = argsPtr->output;
    int _frequency = argsPtr->frequency;
    char _binaryDecodedCharacter = argsPtr->binaryDecodedCharacter;

    int _threadTurn = argsPtr->threadTurn;
    // pthread_mutex_t* _bsem = argsPtr -> bsem;
    // pthread_cond_t* _waitTurn = argsPtr -> waitTurn;
    int *_turn = argsPtr->turn;

    // Unlock Mutex
    pthread_mutex_unlock(argsPtr->bsem);
    //! End of Critical Section

    // Do HuffmanCode Printing
    treeNode *currNode = _huffmanTreeRoot;

    // traverse tree to find binaryCode's respective character
    for (int i = 0; i < _binaryMsg.length(); i++)
    {
        if (_binaryMsg[i] == '0')
            currNode = currNode->left;

        else if (_binaryMsg[i] == '1')
            currNode = currNode->right;
    }

    pthread_mutex_lock(argsPtr->bsem);

    // Wait for correct turn
    while (_threadTurn != (*_turn))
    {
        pthread_cond_wait(argsPtr->waitTurn, argsPtr->bsem);
    }

    pthread_mutex_unlock(argsPtr->bsem);

    std::cout << "Symbol: " << currNode->character << ", Frequency: " << currNode->charFrequency
              << ", Code: " << _binaryMsg << std::endl;

    //! Critical Section Beginning
    // Lock Mutex
    pthread_mutex_lock(argsPtr->bsem);

    (*_turn)++;

    // Broadcast to wake all threads and see who's turn it is next
    pthread_cond_broadcast(argsPtr->waitTurn);
    pthread_mutex_unlock(argsPtr->bsem);
    //! Second Critical Section End

    // PA1 Code
    _binaryDecodedCharacter = currNode->character;
    _frequency = currNode->charFrequency;

    // place character in the correct position in our outputVector
    for (int i = 0; i < _frequency; i++)
    {
        int charPosInVector = _positionsVector.at(i);
        *(_output + charPosInVector) = _binaryDecodedCharacter;
    }

    return nullptr;
}

int main(int argc, char *argv[])
{
    // TODO: Fix the way we read inputs, for PA3 we're using STDIN
    // TODO: and we're only reading from input, not input & compressed

    //* Input Format
    // 1st Line -> Will contain a number (m) representing the number of unique letters in the message
    // Next n Lines ->  will contain a letter followed by its frequency
    // Last n Lines -> will contain a binary string, followed by its positions in the original message

    //! VSCode Testing in Terminal
    //! ./mainExe < inputFileName
    int numOfUniqueLetters;

    std::cin >> numOfUniqueLetters;
    std::cin.ignore();

    std::string inputBuffer;
    std::string compBuffer;

    // container that we'll use to store characters and their respective frequencies
    std::map<char, int> freqContainer;
    int outputVectorSize = 0;

    // For huffmanTree building
    for (int i = 0; i < numOfUniqueLetters; i++)
    {
        std::getline(std::cin, inputBuffer);
        // std::cout << "Input Line " << i << ": " << inputBuffer << std::endl;

        char symbol;
        int freq;

        symbol = inputBuffer[0];
        freq = stoi(inputBuffer.substr(2));

        freqContainer[symbol] = freq;
        outputVectorSize += freq;
    }

    // can now call pthread_mutex functions to do as needed
    // mutexArguments& callMutexFunction = mutexArguments::GetInstanceOf();
    // callMutexFunction.mutexInitialization();

    huffmanTree HTree;
    treeNode *treeRoot = HTree.buildHuffmanTree(freqContainer);

    //! Printing in different manner now
    // //std::string str = "";
    // //HTree.encodeCharacter(treeRoot, str);

    //* Huffman Code Printing Order
    // Will print codes in the order that they appear in the "Last n Lines" from Input
    // Will be done in threading function

    static pthread_mutex_t bsem;
    static pthread_cond_t waitTurn;

    // need something that holds where each character belongs in the string and something
    // that holds the characters so we can later construct our message from it
    std::vector<int> charPositions;
    std::vector<char> outputVector(outputVectorSize);

    // thread initialization stuff
    std::vector<pthread_t> threadsVector;
    threadArguments args = threadArguments();

    // set correct turn for each thread
    int correctThreadTurn = 0;

    for (int i = 0; i < numOfUniqueLetters; i++)
    {
        std::getline(std::cin, compBuffer);
        // std::cout << "Compressed Line " << i << ": " << compBuffer << std::endl;

        std::istringstream ss(compBuffer);
        std::string binaryStringToDecode;
        int characterIndexes;

        // compFile parsing
        ss >> binaryStringToDecode;

        while (ss >> characterIndexes)
        {
            charPositions.push_back(characterIndexes);
        }

        // outputVector.data() points to the first element in the vector (needed since argsStruct uses a char pointer)
        // TODO: Fix this -> ""You cannot use different memory addresses to pass the information from the parent thread to the child threads.""
        //  //threadArguments* args = new threadArguments(treeRoot, binaryStringToDecode, charPositions, outputVector.data(), &callMutexFunction, correctThreadTurn);
        args.huffmanTreeRoot = treeRoot;
        args.binaryMsg = binaryStringToDecode;
        args.positionsVector = charPositions;
        args.output = outputVector.data();
        args.threadTurn = correctThreadTurn;
        args.bsem = &bsem;
        args.waitTurn = &waitTurn;
        // args.turn = &mTurn;

        pthread_t thread;

        pthread_mutex_lock(&bsem);

        args.turn = &i;

        if (pthread_create(&thread, NULL, printTreeAndDecodeBinaryString, &args))
        {
            std::cout << "Failed to Create Thread" << std::endl;
        }

        //! Checking that parent thread is passing same memory address to child threads
        // std::cout << "Memory Address: " << &args << std::endl;

        // push threads and args into their respectice vectors
        threadsVector.push_back(thread);

        // clear vector so threads don't mix up previous character positions
        charPositions.clear();

        correctThreadTurn++;
    }

    // join threads, at this point all threads have input info into the outputVector
    for (int i = 0; i < threadsVector.size(); i++)
    {
        pthread_join(threadsVector[i], NULL);
    }

    //* Original Message
    // Same as PA1 and PA2

    std::string finalMessage = "";

    for (int i = 0; i < outputVector.size(); i++)
    {
        finalMessage += outputVector[i];
    }

    std::cout << "Original message: " << finalMessage << std::endl;

    return 0;
}